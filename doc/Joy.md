# Joy に関する非公式のチュートリアル
マンフレッド・フォン・トゥーン著
2003 年 2 月改訂

この改訂版には、John Cowan (2001) の拡張機能への参照が含まれています。

## 要約:

Joy は、引数への関数の適用ではなく、関数の合成に基づいた関数型プログラミング言語です。
式のラムダ抽象化は使用せず、代わりに式の引用符を使用します。
デクォーテーションを実行するには多数のいわゆるコンビネータが使用され、高次関数の効果があります。
それらのいくつかは、再帰的な定義を排除するために使用できます。
Joy のプログラムはコンパクトで、多くの場合、後置記法のように見えます。
仮パラメータを実際のパラメータに置き換えることがないため、プログラムの作成とその推論が容易になります。

このチュートリアルでは、すべての実装で同じと考えられる Joy 言語の基本的な機能について説明します。

キーワード:関数型プログラミング、高階関数、関数の合成、コンビネータ、再帰定義の削除、変数自由表記

## 導入

ジョイの理論は興味深いものですが、このチュートリアルの説明では理論を可能な限り避けています。
この文書の残りの部分は次のように構成されています。
 この導入セクションでは、この言語のいくつかの際立った機能の非常に短い概要を続けます。
次の 2 つのセクションでは、基本的なデータ型とその操作について説明します。
その後のセクションは、Joy の中心的な機能であるプログラムの引用とコンビネータでのそれらの使用に戻ります。
定義に関する短いセクションの後、次のセクションではコンビネータ、特に再帰的定義の必要性を排除できるコンビネータについての説明を再開します。
最後のセクションでは、いくつかの短いプログラムと 1 つの大きなプログラムを使用して、Joy での集合体を使用したプログラミングを説明します。
2 つの整数、たとえば 2 と 3 を加算し、その合計を書き込むには、次のプログラムを入力します。

```
        2 3 +
```

これは通常の後置記法であり、1920 年代にポーランドの論理学者によって最初に使用された記法を逆にしたものです。
この利点は、複雑な式では括弧が必要ないことです。
内部的には次のように動作します。
最初の数字により、整数 2 がスタックにプッシュされます。
2 番目の数字により、その上に整数 3 が追加されます。
"."次に、加算演算子は 2 つの整数をスタックからポップし、それらの合計 5 をプッシュします。
システムは上記のような入力を読み取り、次のように ピリオドで終了するとそれらを実行します。

  
```
        2 3 + .
```

デフォルト モードでは、明示的な出力命令は必要ないため、数値は5出力ファイル (通常は画面) に書き込まれます。
したがって、デフォルト モードでは、終了は"."スタックの最上位要素に書き込む命令であるとみなされる可能性があります。
これ以降、終了期間は表示されません。

整数とは別に、John Cowan によって拡張された現在のバージョンの Joy には実数または「浮動小数点」が含まれています。
浮動小数点数の算術演算は、整数の算術演算とまったく同じです。
次の例では 2 つの数値を乗算します

  
```
        2.34 5.67 *
```

そしてその積 を13.2678スタックの一番上に残します。
(したがって、ターミナルで結果を確認するには、上記の行をピリオドで終了する必要があります。
)
整数の 2 乗を計算するには、それ自体を乗算する必要があります。
2 つの整数の合計の 2 乗を計算するには、合計をそれ自体で乗算する必要があります。
できれば、合計を 2 回計算せずにこれを実行する必要があります。
以下は、2 と 3 の和の 2 乗を計算するプログラムです。

```
        2 3 + dup *
```

2 と 3 の合計が計算された後、スタックには整数 5 だけが含まれます。
dup次に、オペレーターは 5 の別のコピーをスタックにプッシュします。
次に、乗算演算子は 2 つの整数をその積 (5 の 2 乗) に置き換えます。
その後、2 乗値は 25 として書き出されます。
演算子とは別に、dup スタックの先頭を再配置するための演算子がいくつかあります。
演算子popは最上位の要素を削除し、 swap演算子は、上の 2 つの要素を交換します。
スタックマニピュレータはスタックが存在する場合にのみ意味をなすため、これは適切な後置表記とはまったく異なります。
このような表記法は、一部の電卓、Unix ユーティリティ dc、写植言語 Postscript、および汎用言語 Forth でも使用されています。
Billy Tanksley は、これを連結記法と呼ぶことを提案しました。
この表記法の理論はそれ自体がトピックですが、このチュートリアルでは扱いません。

整数のリストは角括弧内に記述されます。
整数を追加したり操作したりできるのと同じように、リストもさまざまな方法で操作できます。
以下はconcatで2つのリストを作成します。

  
```
        [1 2 3] [4 5 6 7] concat
```

2つのリストが最初にスタックにプッシュされます。
次に、 concatオペレーターはそれらをスタックからポップし、リストを[1 2 3 4 5 6 7]スタックにプッシュします。
そこでさらに操作されるか、出力ファイルに書き込まれる可能性があります。

リストの要素はすべて同じ型である必要はなく、要素自体がリストであってもかまいません。
以下では、1 つの整数、2 つの浮動小数点数、および 3 つの整数からなる 1 つのリストを含むリストを使用します。

  
```
        [ 3.14 42 [1 2 3] 0.003 ] dup concat
```

オペレーターdupはリストのコピーをスタックの最上部にプッシュし、そこで 2 つのリストが 1 つに連結されます。

Joy はコンビネータ を多用しています。
これらは、スタックの最上位に特定のものを期待するという点で演算子に似ています。
ただし、演​​算子とは異なり、スタックの最上部で見つけたものを実行します。
これは角括弧で囲まれたプログラムの引用符である必要があります。
mapはこれらの1つで、関数を介してあるリストの要素を別のリストにマッピングするためのコンビネータです。
プログラムを検討してみよう
  
```
        [1 2 3 4] [dup *] map
```

まず整数のリストをプッシュし、次に引用符で囲まれたプログラムをスタックにプッシュします。
次に、コンビネータmapはリストと引用符を削除し、指定されたリストの各メンバーにプログラムを適用して別のリストを作成します。
[1 4 9 16]結果は、スタックの一番上に残る リストです。

新しい関数の定義 では仮パラメータは使用されないため、仮パラメータを実際のパラメータで置き換えることはありません。
次の定義の後
  
```
        square == dup *
```

記号 square は dup * の代わりに使用できます。

定義は次のようなブロック内で行われます。
  
```
    DEFINE
        square == dup * ;
        cube == dup dup * * .
```

例が示すように、定義モードは予約語によって開始され DEFINE、ピリオドまで拡張されます。
個々の定義はセミコロンで区切られます。
LIBRAライブラリでは、の代わりにイニシエータが使用されますDEFINE。
この文書の残りの部分では、イニシエーター、セパレーター、およびターミネーターは通常、これ以上示されません。

他のプログラミング言語と同様に、階乗関数の定義など、定義は再帰的になる場合があります。
この定義では、他の場所でも役立つ特定の再帰パターンが使用されます。
Joy には、このパターンが組み込まれているプリミティブ再帰用のコンビネータがあり、定義の必要性を回避します。
コンビネータ primrecは、データ パラメータに加えて、引用符で囲まれた 2 つのプログラムを予期します。
整数データ パラメータの場合、次のように動作します。
データ パラメータがゼロの場合、最初の引用符で返される値を生成する必要があります。
データ パラメータが正の場合、2 番目のパラメータはデータ パラメータとその先行関数に関数を適用した結果を結合する必要があります。
階乗関数の場合、必要な引用符で囲まれたプログラムは非常に単純です。
  
```
        [1] [*] primrec
```

階乗を再帰的に計算します。
定義など必要ありません。
たとえば、次のプログラムは5の階乗を計算します。

  
```
        5 [1] [*] primrec
```

まず番号をプッシュし5、次に引用符で囲まれた 2 つの短いプログラムをプッシュします。
この時点で、スタックには 3 つの要素が含まれています。
次に、primrecコンビネータが実行されます。
2 つの引用符をスタックからポップし、別の場所に保存します。
次に、 primrecスタックの最上位要素 (最初は ) が5ゼロに等しいかどうかをテストします。
存在する場合、それをポップして引用符の 1 つを実行し、結果としてスタックに1を残します。
それ以外の場合は、最上位要素のデクリメントされたコピーをプッシュし、再帰します。
再帰から戻る途中で、もう 1 つの引用符 を使用して、[*]スタック上の階乗になっているものとスタック上の 2 番目の要素を乗算します。
すべてが完了すると、スタックには5の階乗である120が含まれます。

このプログラムからわかるように、再帰的定義の通常の分岐がコンビネータに組み込まれています。
コンビネータprimrecを他の多くの引用パラメータとともに使用して、まったく異なる関数を計算できます。
整数以外のデータ型でも使用できます。

Joy には、ユーザーに再帰的定義または非再帰的定義を強制することなく、
多くの関数を計算するために使用できるさらに多くのコンビネータがあります。
コンビネータの中には、primrecよりもデータに特化したものもあれば、はるかに一般的なものもあります。


## 整数、浮動小数点、文字、および真理値

Joy のデータ型は、単純型と集計型に分類されます。
単純な型は、整数、浮動小数点 (または実数)、文字、および真理値で構成されます。
集計タイプは、セット、文字列、リストで構成されます。
任意の型のリテラルにより、その型の値がスタックにプッシュされます。
そこでは、dup 、pop、swapおよびその他のいくつかの一般的なスタック操作によって操作することも、その型に固有の演算子によって操作することもできます。
このセクションでは、単純型のリテラルと演算子を紹介します。

整数は単なる整数です。
このタイプのリテラルは 10 進数表記で記述されます。
次の二項演算が提供されます。
  
```
        + - * / rem
```

最初の 4 つは従来の意味を持ち、最後のものは除算後の剰余の演算子です。
演算子はオペランドの後に記述します。
二項演算子は、スタックの最上位から 2 つの値を削除し、結果で置き換えます。
たとえば、プログラムは
  
```
        20 3 4 + * 6 - 100 rem
```

は 34 と評価され、この値はスタックの一番上に残ります。
absまた、絶対値を取得する演算子や、 パラメーターが負、ゼロ、正のいずれであるかに応じて、
-1、0または-1を生成するsignum演算子など、整数に固有の単項演算子もいくつかあります。
正と負の整数または整数とは別に、Joy には浮動小数点数または「float」があります。
このタイプのリテラルは、小数点とその後に少なくとも 1 桁の数字を付けて記述されます。
オプションで、最後の数字の後に「E」または「e」を続け、その後に正または負の指数を続けることができます。
ここではいくつかの例を示します。
  
```
        3.14 314.0 3.14E5 3.14e-5
```

最後の 2 つは、 314000.0 および 0.0000314 に相当します。
整数に対するほとんどの演算子は、浮動小数点に対しても同じように機能します。
John Cowan の拡張機能では、float 用の多数の関数も提供されていますが、これらはこのチュートリアルの範囲外です。

文字とは、文字、数字、句読点文字であり、実際には印刷可能な文字、またはいくつかの空白文字の 1 つです。
文字型のリテラルは、一重引用符の後に文字自体が続くように記述されます。
文字型の値は、小さな数値と非常によく似たものとして扱われます。
これは、他の数字を追加できることを意味します。
たとえば、文字を大文字から小文字に変更するには 32 を追加します。
文字と整数に対して定義されている 2 つの単項演算子があります。
pred先行演算子を取得し、succ後続演算子を取得します。
例えば、
  
```
        'A 32 + succ succ
```

3番目の小文字である'cと評価されます。

真理値sの型は、一部の言語ではBooleanと呼ばれるものです 。
以下に、2 つのリテラル、単項否定演算子、および論理積と論理和のための 2 つの二項演算子を示します。
  
```
        true false not and or
```

たとえば、プログラムは

```
        false true false not and not or
```

falseと評価されます。

整数型と文字型の値は、次の関係演算子 を使用して比較できます。
  
```
        = < > != <= >=
```

!=演算子は、演算子=が返す値の否定を返します。
その他は従来の意味を持ちます。
すべての演算子と同様に、これらは後置表記で書かれます。
結果は常に真理値です。
例えば、
  
```
        'A 'E < 2 3 + 15 3 / = and
```

はtrueと評価されます。


## セット、文字列、リスト

集約タイプは、セットの順序なしタイプと、文字列およびリストの順序付きタイプです。
集合体は、構築、結合、分解し、メンバーシップをテストすることができます。
このセクションでは、集計タイプのリテラルと演算子を紹介します。

セットは、0 個以上の小さな整数の順序付けされていないコレクションです。
型セットのリテラルは中括弧内に記述され、空のセットは空の中括弧のペアとして記述されます。
セット リテラルの場合、要素の順序は無関係であり、重複は影響しません。
論理積と論理和の演算子もセットで定義されます。
たとえば、2 つの同等のプログラムは、
  
```
        {1 3 5 7} {2 4 6 8} or {} or {3 4 5 6 7 8 9 10} and
        {3 7 5 1} {2 4 6 8} or {} or {3 4 5 6 7 8 9 10 10} and
```

{3 4 5 6 7 8}と評価されます。
否定演算子は、 not表現可能な最大セットに対する補数を受け取ります。
ほとんどの実装では、最大 32 個のメンバーが含まれます ( from から0) 31。

文字列は、0 個以上の文字の順序付けされたシーケンスです。
この文字列型のリテラルは二重引用符で囲まれ、空の文字列は 2 つの隣接する二重引用符の中に何も含まれないように書かれます""。
これは、空白だけを含む文字列とは異なることに注意してください: " "。
2 つの文字列を連結したり、文字列を反転したりできます。
例えば、

  
```
    「dooG」逆「朝」「」連結連結「世界」連結
```

と評価されます"Good morning world"。

多くの演算子の場合、実装はそれをプリミティブにするかライブラリで定義するかを選択できます。
実行速度を除けば、ユーザーにとってはどちらを選択したかは関係ありません。
現在の実装では、reverse演算子はライブラリで定義されています。


リストは、任意の型の 0 個以上の値の順序付けされたシーケンスです。
list 型のリテラルは角括弧内に記述され、空のリストは空の括弧のペアとして記述されます。
リストにはメンバーとしてリストを含めることができるため、リストの型は再帰データ型になります。


集計タイプの値、つまりセット、文字列、およびリストは、演算子を使用して新しいメンバーを追加することによって、既存の値から構築できます cons。
これは二項演算子であり、最初のパラメーターは可能な新しいメンバーである必要があり、2 番目のパラメーターは集計である必要があります。
セットの場合、新しいメンバーが存在しない場合は追加され、文字列とリストの場合、新しいメンバーが前に追加されます。
ここではいくつかの例を示します。
左側のプログラムは右側のリテラルとして評価されます。


  
```
        5 3 {2 1} 短所 短所 3 スワップ 短所 {1 2 3 5}
        'E 'C "AB" コンスコンス 'C スワップコンス "CECAB"
        5 [6] [1 2] コンス コンス 'A スワップ コンス ['A 5 [6] 1 2]
```

例が示すように、このcons演算子は、集約の下のスタック上に既に存在する集約に要素を追加する場合に最も役立ちます。
プッシュされたばかりの新しい要素を追加するには、新しい要素を集約に追加するswap前に、まず新しい要素と集約を ped する必要があります。
consこれを容易にするために、Joy には別のオペレーター があり、 swons最初に を実行しswap、次に を 実行しますcons。

consandswons演算子は集計値を構築する のに対し、2 つの単項演算子はそれらを分解しfirstます rest。
どちらも空ではない集計値でのみ定義されます。
2 つの順序付けされた集計タイプ、文字列とリストの意味は明らかです。
最初の演算子は最初の要素を返し、残りの演算子は最初の要素を含まない文字列またはリストを返します。


  
```
        「CECAB」最初の「C」
        「CECEB」レスト「ECAB」
        ['A 5 [6] 1 2] 最初の 'A
        ['A 5 [6] 1 2] 残り [5 [6] 1 2]
```

しかし、セットには順序がないので、最初のメンバーをセットとして 話すのは意味がありません。
ただし、それらのメンバーは整数であるため、整数の順序を使用して最初のメンバーが何であるかを決定できます。
同様の考慮事項がrest 演算子にも適用されます。

  
```
        {5 2 3} 最初の 2
        {5 2 3} 休憩 {3 5}
```

3 種類の集計すべてについて、最初のメンバー以外のメンバーは、残りを繰り返し取得し、最後にその最初のメンバーを抽出することで抽出できます。
これは、内部のメンバーを抽出するのが面倒になる可能性があります。
別の方法は、数値的に指定された位置にある メンバーを抽出することにより、演算子atを使用して集計にインデックスを付けることです。
たとえば、以下は、集計の 5 番目のメンバーを抽出する 2 つの同等のプログラムです。


  
```
        休みなさい 休みなさい 休みなさい まずは休みなさい
        5時
```

size集計値を 決定する単項演算子があります。
セットの場合はメンバーの数、文字列の場合は長さ、リストの場合は最上位のメンバーのみをカウントした長さです。
このsize演算子は、空の集計の場合はゼロを返し、その他の場合は正の整数を返します。
空の集合体やその他の集合体に対してnull真理値を与える述語で ある単項演算子もあります 。
別の述語である演算子は、サイズがまたは の 場合にのみ結果を返します 。
 truefalsesmalltrue01

スタックにのみ影響する演算子とは別に、明示的な入力と出力用の演算子が 2 つあります。
オペレーターgetは入力ファイルから項目を読み取り、それをスタックにプッシュします。
オペレーター putはスタックから項目をポップし、それを画面または出力ファイルに書き込みます。
次のプログラムは、2 つの整数ペアを読み取り、最初のペアの合計と 2 番目のペアの合計を比較します。


  
```
        取得 取得 + 取得 取得 + > 置く
```

2 人のgetオペレーターは 2 つの項目を読み取り、スタックにプッシュしようとします。
そこではすぐに追加されるため、整数である必要があります。
これを 2 番目のペアでも繰り返します。
この時点で、スタックには 2 つの合計が含まれています。
次に、比較演算子は 2 つの整数をポップし、最初の合計が 2 番目の合計より小さいかどうかに応じて、真理値、true またはに置き換えます。
false演算子putはその真理値をポップして書き込みます。
スタックはプログラム実行前の状態のままになり、入力ファイルと出力ファイルのみが変更されます。

別の例として、以下は愚かな小さな対話を実行します。



  
```
        "あなたの名前は何ですか？" put "Hello", get concat put
```

まず質問文字列がスタックにプッシュされ、次にポップされて画面に書き出されます。
次に、「Hello, "」文字列がプッシュされます。
次に、getオペレーターはキーボードから項目を読み取り、それをスタックにプッシュします。
この項目はスタック上でその下にあるものと連結されるため、別の文字列である必要があります。
結果の文字列が書き出されます。
したがって、質問への答えとしてユーザーが'"Pat"'と入力すると、プログラムは最終的に '"Hello, Pat"'を書き出します。

John Cowan の拡張機能は、複合データ型セット、文字列、リストに加えて、ファイル システムを操作するための多数の演算子 (ファイルを開く、閉じる、削除する、さまざまな入出力演算子) を提供します。
これらはこのチュートリアルの範囲外です。


## 引用符と結合子

リストは実際には、引用符で囲まれたプログラム の特殊なケースにすぎません。
リストにはさまざまなタイプの値のみが含まれますが、引用されたプログラムには、演算子や以下で説明するその他の要素などの他の要素が含まれる場合があります。
引用はリストと同様に受動的なデータ構造として扱うことができます。
例えば、
  
```
        [ + 20 * 10 4 - ]
```

size があり6、その 2 番目と 3 番目の要素は 20andであり*、逆にすることも、他の引用符と連結することもできます。
ただし、受動的な引用は、 dequoteによってアクティブにすることもできます。

上記の引用符がプログラム内で発生すると、リストがプッシュされるのと同じように、引用符がスタックにプッシュされます。
その引用がスタックの一番上に置かれる可能性がある方法は他にもたくさんあります。
その部分から連結したり、より大きな引用から抽出したり、入力から読み取ったりすることができます。
どのようにスタックの最上位に置かれたとしても、データ構造として受動的に、またはプログラムとして能動的に処理するという 2 つの方法で処理できるようになりました。
角括弧により、積極的に処理することができなくなりました。
これらがなければプログラムは実行されます。
プログラムは 2 つの整数を期待して加算し、その結果を 20 で乗算し、最後に 10 と 4 の差である 6 をプッシュします。


Joy にはコンビネータと呼ばれる特定のデバイスがあり、スタックの最上部にある引用されたプログラムを実行します。
このセクションでは、それらのうちのごく一部のみを説明します。


最も単純なものの 1 つはiコンビネータです。
その結果、スタックの最上位で単一のプログラムが実行され、他には何も実行されません。
構文的に言えば、その効果は引用角括弧を削除し、引用されたプログラムを実行用に公開することです。
したがって、次の 2 つのプログラムは同等です。


  
```
        [ + 20 * 10 4 - ] i
          + 20 * 10 4 -
```

コンビネータiは主に理論的に重要ですが、時々使用されます。
他の多くのコンビネータは、Joy でのプログラミングに不可欠です。

最もよく知られているコンビネータの 1 つは分岐用です。
コンビネータ ifteは、スタック上に 3 つの引用符で囲まれたプログラム (if 部分、then 部分、else 部分がこの順序で、else 部分が一番上にある) を想定します。
コンビネータifteは 3 つの引用符を削除して保存し、スタックの残りの部分に対して次の処理を実行します。
スタックの一番上に真理値を残す if 部分を実行します。
その真理値は保存され、スタックは if 部分の実行前の状態に復元されます。
次に、保存された真理値が であった場合true、ifte コンビネータは then 部分を実行し、それ以外の場合は else 部分を実行します。


ほとんどの場合、コンビネータが実行される直前に、3 つの部分がこの順序でプッシュされますifte。
しかし、3 つの部分の一部またはすべてが他の引用から構成された可能性があります。


次の例では、コンビネータが実行される直前に 3 つの部分がプッシュされます ifte。
プログラムはスタックの一番上の数値を調べ、それが 1000 より大きい場合は半分にし、そうでない場合は 3 倍にします。


  
```
        [1000 >] [2 /] [3 *] イフテ
```
一部のコンビネータでは、スタックに特定の型の値が含まれている必要があります。
多くは、他のプログラミング言語でよく知られている高次関数 ( map、filter、 ) に似ていますfold。
他の人は喜びの中でのみ意味を持ちます。
たとえば、 stepコンビネータを使用して、集合体のすべての要素に順番にアクセスできます。
文字列とリストの場合、これはそれらの出現順序を意味し、セットの場合、それは基礎となる順序を意味します。
以下では、step2 番目のリストのメンバーを調べて、swons最初は空の最初のリストに入れます。
その結果、空ではないリストが反転され、 が得られます[5 6 3 8 2]。


  
```
        [] [2 8 3 6 5] [スウォン] ステップ
```
コンビネータmapはスタックの最上位に集計値を期待し、同じサイズの別の集計値を生成します。
新しい集計の要素は、引用されたプログラムを元の集計の各要素に適用することによって計算されます。
例はすでに導入部で示されています。


集計を期待するもう 1 つのコンビネータはfilter コンビネータです。
引用されたプログラムは真理値を生成する必要があります。
結果は、引用されたプログラムが生成する元の要素を含む、同じタイプの新しい集合体ですtrue。
たとえば、引用符で囲まれたプログラムは、['Z >]数値が の数値より大きい文字に対して true を返します Z。
したがって、文字列から大文字と空白を削除するために使用できます。
したがって、以下は次のように評価されます "ohnmith"。


  
```
        「ジョン・スミス」['Z >] フィルター
```
場合によっては、集計値のすべての要素を加算、乗算、または結合することが必要になることがあります。
コンビネータfoldはまさにそれを行うことができます。
これには、折り畳まれる集合体、集合体が空のときに返される引用符で囲まれた値、要素を結合するために使用される引用符で囲まれた二項演算の 3 つのパラメーターが必要です。
言語によっては、コンビネータは、reduce (集計値を 1 つの値に変換するため)、または insert (2 項演算が任意の 2 つのメンバー間に挿入されたように見えるため) と呼ばれます。
次の 2 つのプログラムは、リストのメンバーの合計とリストのメンバーの二乗の合計を計算します。
それぞれ 10 と 38 と評価されます。


  
```
        [2 5 3] 0 [+] 倍
        [2 5 3] 0 [dup * +] フォールド
```

セットまたはリストのメンバーの平均または算術平均を計算するには、合計をサイズで割る必要があります。
(整数演算のため、除算では不正確な平均が生成されます。
) 集計は 2 回調べる必要があります。
1 回目は合計、もう 1 回目はサイズです。
したがって、平均を計算する 1 つの方法は、まず演算子を使用して集計値を複製することですdup。
次に、 sum最上位バージョンの を取得します。
次に、swap 演算子を使用して合計と元の集計の位置を交換し、元の集計がスタックの一番上に来るようにします。
それのサイズを測ってください。
これで、スタックには合計とサイズが含まれ、サイズが一番上になります。
除算演算子を適用して平均値を取得します。


  
```
        dup 0 [+] フォールド スワップ サイズ /
```

この小さなプログラムの優れた機能の 1 つは、設定値に対してもリスト値に対しても同様に機能することです。
これは、構成要素 foldとsize機能が両方のタイプに対応しているためです。

しかし、このプログラムには満足できない点が 2 つあります。
1 つは、プログラムを読みにくくするdupおよび演算子に関するものです。
swapもう 1 つは、操作の順序に関するものです。
プログラムにより、サイズの計算の前に合計の計算が行われます。
ただし、計算される順序は問題ではありません。
実際、複数のプロセッサを備えたマシンでは、合計とサイズを並行して計算できます。
 Joy には、この問題に対処するコンビネータがあります。
データ パラメータが1 つあり、集計値が2 つの関数に供給されます 。
コンビネータ切断によって両方の関数を呼び出すことにより、各関数から値が構築されます。
 これにより、合計とサイズの 2 つの値が生成されます。
平均のプログラムは次のようになります。


  
```
        [0 [+]折り] [サイズ] 折り目 /
```

## 定義

従来の言語では、1 つ以上の引数の関数を定義するには、これらを仮パラメータとして指定する必要がありますx。
 yたとえば、二乗関数は、次のいずれかのバリエーションによって定義される可能性があります。

  
```
        平方(x) = x * x
        (でふん(四角×)(*××))
        平方 = ラムダ xx * x
```

Joy では、x上記のような仮パラメータは必要ありません。
二乗関数の定義は単純です。

  
```
        正方形 == 二重 *
```

これは、Joy とラムダ計算に基づく言語との主な違いの 1 つです。
後者には、Lisp、Scheme、ML、Haskell (の純粋に機能的なサブセット) が含まれます。
これらはすべて、引数または実際のパラメータへの関数の適用に基づいています。

関数の定義と抽象化では、仮パラメータには - など、またはより有益な名前を付ける必要がありxますy。
これがジョイでは違います。
これは、関数の引数への適用ではなく、関数の合成に基づいています。
関数の定義と抽象化では、引数に名前を付ける必要はなく、仮パラメータとして実際に名前を付けることはできません。
結果の 1 つは、名前と値のペアの環境が存在しないということです。
代わりに、環境の作業はコンビネータと呼ばれる高次関数によって実行されます。


最後に、言語の具体的な構文は言語の不可欠な部分であり、メタ言語で Joy プログラムについて推論するのに役立ちます。


数値のリストをその立方体のリストに変換する必要があるとします。
もちろん、単一の数値の 3 乗は次のように計算されます。


  
```
        ダップダップ * *
```

立方体関数の定義を導入することは可能です。
しかし、それは別の名前、 を導入することになりますcube。
cube 関数が数値リストの 3 乗を計算するために 1 回だけ使用される場合、関数の定義をまったく与えることは望ましくない可能性があります。
Joy では、立方体のリストは以下の 1 行目で計算されますが、2 行目のように明示的に定義することも可能です。

  
```
        [ダップダップ * *] マップ
        cubelist == [dup dup * *] マップ
```

ラムダ計算に基づく言語では、両方とも、数値をx3 乗するための変数、たとえば を使用したラムダ抽象化が必要になります。
そしてもちろん、2 行目には追加の仮パラメータ、つまりcubelist 関数が適用されるリスト lの変数を含むラムダ抽象化が必要になります。
l
ここで、 数値のリストのリストをその立方体のリストのリストに変換する必要があるとします。
定義を与えるかもしれない

  
```
        cubelistlist == [ [dup dup * *] マップ ] マップ
```

もちろん、その関数が 1 回だけ使用される場合は、わざわざ定義を与える必要はなく、右辺を直接使用することもできます。
抽象化に基づく言語では、右辺だけで少なくとも 2 つの仮パラメータが必要であり、定義自体にはもう 1 つが必要です。
たとえば、Scheme では定義は次のようになります。

  
```
        (定義 (cubelistlist ll)
                (マップ (ラムダ (l)
                     (マップ (ラムダ (n) (* n (* nn)))
                           l))
                 ll）
```

ここで、2 つの仮パラメータは、右側の n数値と 数値のリスト、および定義自体の数値のリストのリストです。
 lll
他の言語と同様に、Joy では定義を再帰的に行うことができます。
以下の最初の行は、従来の表記法の多くの変形のうちの 1 つでの階乗関数の再帰的定義です。
2 行目は Joy での再帰的な定義です。


  
```
        階乗(x) = x = 0の場合は1、それ以外の場合はx *階乗(x - 1)
        階乗 == [0 =] [ポップ 1] [dup 1 - 階乗 *] ifte
```

繰り返しになりますが、Joy バージョンでは仮パラメータは使用されませんx。
それは次のように動作します。
定義ifteでは、if 部分、then 部分、else 部分がプッシュされた直後にコンビネータが使用されます。

次に、コンビネータはこれを実行します。
この場合は、(匿名の) 整数パラメータがゼロに等しいかどうかをテストするifteif 部分を実行します。
[0 =]そうである場合、if 部分が実行されます。
この場合[pop 1]、パラメータがスタックからポップされ、1 に置き換えられます。
それ以外の場合は、else 部分が実行されます (この場合) [dup 1 - factorial *]。
これは、dupパラメータの別のコピーを作成し、そのコピーから 1 を減算するために使用されます。
次に、 factorialその関数が再帰的に呼び出されます。
最後に、元のパラメータと計算された階乗が乗算されます。


nullゼロをテストする組み込みの述語とpred数値の前身を取る演算 子を使用することで、定義を短縮し、もう少し効率的にすることができます。
しかし、これらの変化は重要ではありません。


複数の引数を含むより複雑な関数の場合は、定義内のどこにでも引数にアクセスできる必要があります。
Joy は形式パラメータを完全に回避するため、一般に任意のアクセスは、 、 、 よりも洗練されたメカニズムによって実行する必要がdupあり swapますpop。


他にも次のような定義があります。



  
```
        合計 == 0 [+] 倍
        製品 == 1 [*] 倍
        平均 == [合計] [サイズ] constr12 /
        連結 == "" [連結] 折りたたむ
```

最後の定義は、文字列のリストを連結した単一の文字列を生成する演算子用です。


## 再帰的コンビネータ

与えられたリストの階乗のリストを計算したい場合、これは次のように行うことができます。

  
```
        [ 階乗 ] マップ
```
しかし、これは階乗の外部定義に依存します。
この定義は再帰的であるため、明示的に指定する必要がありました。
数値のリストの階乗を計算したいだけであれば、定義が再帰的であるという理由だけで階乗を明示的に定義することを強いられるのは少々面倒です。

再帰的に定義された関数の高い割合は非常に単純なパターンを示します。
つまり、基礎ケースが得られるかどうかを決定する何らかのテスト (if 部分) があります。
存在する場合、非再帰の then-part が実行されます。
それ以外の場合は、再帰的な else 部分を実行する必要があります。
else 部分には再帰呼び出しが1 つだけあり、再帰呼び出しの前と再帰呼び出しの後に何かが存在する可能性があります。
else 部分には、再帰呼び出しの前の else1 部分​​と再帰呼び出し後の else2 部分の 2 つのコンポーネントがあると考えるとわかりやすいでしょう。
このパターンは 線形再帰と呼ばれ、非常に頻繁に発生します。


Joy にはコンビネータという便利なデバイスがあり、これを使用すると、線形再帰パターンを使用して再帰的に定義された可能性linrecのある匿名関数の計算が可能になります。
コンビネータには引用符で囲まれたパラメータが 3 つ必要です が、コンビネータには if 部分、then 部分、else1 部分​​、else2 部分の 4 つが必要です。
たとえば、階乗関数は次のように計算できます。
 iftelinrec

  
```
        [null] [succ] [dup pred] [*] linrec
```

定義は必要なく、上記のプログラムをそのまま使用できます。

線形再帰の if 部分では、パラメーターのタイプに応じた単純な基本条件がテストされることがよくあります。
数値の場合、その条件はゼロになる傾向があり、セット、文字列、リストの場合、その条件は空になる傾向があります。
else1 部分​​は、何らかの方法でパラメータを小さくすることがよくあります。
数値の場合は減分され、セット、文字列、リストの場合は rest.

Joy には、適切な if 部分と else1 部分​​が組み込まれた別の便利なコンビネータがあります。
これは、 primrec2 つの引用パラメータ、線形再帰の (変更された) then 部分と else2 部分を指定するだけで済むコンビネータです。
 。
階乗関数の場合、2 つの引用パラメーターは非常に単純です。


  
```
        [1] [*] プリムレック
```

階乗関数を計算します。
したがって、与えられた数値リストの階乗リストを計算したい場合は、次のいずれかで実行できます。

  
```
        [ [null] [succ] [dup pred] [*] linrec ] マップ
        [ [1] [*] primrec ] マップ
```

数値の階乗は、実際のパラメータまでの連続する自然数の積です。
以下は代わりに、それらの合計と二乗の合計を計算します。

  
```
        [0] [+] プリムレック
        [0] [dup * +] プリムレック
```

Joy コンビネータの多くは、全く異なるタイプのパラメータに適用できるという意味でポリモーフィックです。
コンビネータは primrec数値だけでなくリストにも適用できます。
たとえば、[1 2 3]プログラムを リストに適用すると、
  
```
        [[]] [[] 短所 短所] primrec
```

リストを生成します[1 [2 [3 []]]]。
Lisp プログラマは、「点線ペア」との類似点を認識するでしょう。
以下では、1 つ目は数値のセットをリストに変換し、2 つ目は数値のリストをセットに変換します。

  
```
        [[]] [短所] プリムレック
        [{}] [短所] プリムレック
```

実際、最初の方法はリストにも適用でき、2 つ目はセットにも適用できます。
ただし、その場合は恒等式を計算するだけです。
これらは数値に適用することもでき、パラメータから 1 までの数値のリストまたはセットを生成します。

多くの再帰定義では、定義される関数の再帰呼び出しが 2 回あります。
これは2 項再帰のパターンであり、クイックソートとフィボナッチ関数の通常の定義で使用されます。
Joy には、再帰的定義の必要性を排除する機能、binrecコンビネーターがあります。


次の例では、メンバーにリスト以外のものが混在しているリストをクイックソートします。
このプログラムは 1 行に簡単に収まりますが、参考までに、ここでは番号の付いた複数の行にまたがって記述します。


  
```
    1個[小]
    2 []
    3 [アンコン [>] 分割]
    4 [[swap] dip cons concat]
    5 ビンレック
```

動作の仕組みは次のとおりです。
 1 行目から 4 行目はそれぞれ、引用符で囲まれたプログラムをプッシュします。
5 行目でbinrecコンビネータが呼び出され、引用符で囲まれた 4 つのプログラムとその下にあるソート対象のリストが使用されます。
引用された 4 つのプログラムは別の場所に保存され、binrec コンビネータはプログラムを 1 行目から実行します。
これにより、ソートされるリストが小さいかどうか、つまりメンバーが 1 つ以下かどうかがテストされます。
本当に小さい場合は、すでにソートされています。

コンビネータbinrecはプログラムを 2 行目から実行しますが、何も行わないため、小さなリストはそのまま残ります。
一方、リストが小さくない場合は、3 行目と 4 行目のプログラムが実行されます。
3 行目のプログラムは、リストから最初の要素を削除し、それをピボットとして使用し、比較関数 in とコンビネータを使用してリストの残りを 2 つのサブリストに分割し [>]ますsplit。


この時点で、binrecコンビネータは 2 つのサブリストに対して再帰的に自身を呼び出し、両方を並べ替えます。
最後に、4 行目のプログラムは、2 つのソートされたバージョンと元のピボットを 1 つのソートされたリストに結合します。
3 つの項目は必要な順序になっていないため、この[swap] dipパートでは 2 つの並べ替えられたリストの間にピボットを配置します。


次に、consピボットを最上位の文字列またはリストの前に置き、最後にconcatすべてを 1 つのソート済みリストに結合します。
プログラム内のすべての操作は文字列に対しても機能するため、プログラム自体を文字列の並べ替えにも同様に使用できます。


実際、このプログラムはセットでも使用できますが、もちろんこれには意味がありません。
このプログラムは便利で、 という名前で Joy システム ライブラリの一部ですqsort。


他の多くの関数は、バイナリ再帰を使用する再帰定義によって定義されることがよくあります。
binrecJoy では、定義を必要とせずに、これらはすべてコンビネータで計算できます 。
たとえば、次はフィボナッチ関数を計算します。
通常の非効率的なアルゴリズムを実装します。


  
```
        [小さい] [] [pred dup pred] [+] binrec
```

もちろん、システム ライブラリには、よく知られた効率的なアルゴリズムが含まれています。

2 次コンビネータは少数しかありませんが、パラメータとして 1 次コンビネータを必要とするものもあります。
1 つは、Treetreerecを 再帰するためのものです。
これらはリスト以外のもの、またはツリーのリストのいずれかです。
たとえば、以下では パラメータとして指定されており、リストに遭遇したときにパラメータとして 指定されます。
リスト内に深く埋め込まれている可能性がある数値に適用される関数は、二乗関数です 。


```
treerec[map][dup *]treerec[dup *]
```

以下に例を示します。



  
```
        [ 1 [2 3] [[[4]]] 5 ] [dup *] [map] ツリーレック
```

生成する

  
```
        [ 1 [2 9] [[[16]]] 25 ]
```

これらのコンビネータはすべて他の関数型言語でも定義できますが、そこではあまり役に立ちません。
これは、パラメータが Joy のように引用符ではなく、変数を含む抽象化である必要があるためです。


## 集合体を使用したプログラミング
Joy の集合 タイプはリスト、セット、文字列です。
パラメータとして集計を受け取り、値として部分集計のリストを生成する単項演算子がいくつかあります。
そのうちの 1 つはオペレーターです powerlist。
サイズNの集合体の場合、すべての2^N部分集合体のリストが生成されます。

以下に例を示します。



  
```
        [1 2 3] パワーリスト
```

結果として生成される
  
```
        [ [1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] [] ]
```

順序が合わない場合は、結果リストをいつでも並べ替えることができます。
たとえば、逆にすることもできます。
別の例として、サイズに従ってリストを並べ替えることができます。
コンビネータ mk_qsortはパラメータとして集計と引用符で囲まれた演算子を予期し、演算子を集計の各メンバーに適用して、ソートの基礎として使用します。

  
```
        [1 2 3] パワーリスト [サイズ] mk_qsort
```

結果として生み出す

  
```
        [ [] [1] [2] [3] [1 2] [1 3] [2 3] [1 2 3] ]
```

パワーリスト演算子は文字列にも適用できます。
結果はすべての部分文字列のリストです。
以下では、 filterサイズが 3 より大きい部分文字列のみを保持するように結果リストが編集されます。
これは、filter 集約と引用符で囲まれた述語を期待するコンビネータによって実現されます。
最初の行はプログラム、2 行目は結果です。


  
```
        「abcde」パワーリスト [サイズ 3 >] フィルター
        [ "abcde" "abcd" "abce" "abde" "acde" "bcde" ]
```

パワーリスト演算子はセットにも適用できます。
次に、プログラムの最初の行の下にあるサブセットのリストがフィルタリングされ、サイズ 3 のサブセットのみが保持されます。
結果は 2 行目のサブセットのリストです。


  
```
        {1 2 3 4} パワーリスト [サイズ 3 =] フィルター
        [ {1 2 3} {1 2 4} {1 3 4} {2 3 4} ]
```

与えられた数値セットから取得した 3 つの異なる数値のすべての合計のリストを昇順で検索する必要があるとします。
3 つのメンバーからなるサブセットすべてのリストを取得する方法はすでにわかっています。
mapそれぞれをその合計で置き換える必要があります。
これは、リスト全体に適用されるコンビネータで行うことができます 。
結果として得られる合計のリストを並べ替える必要があります。
最初の行の例はまさにそれを実行し、2 行目に結果を示します。


  
```
        {1 2 3 4 5} パワーリスト [サイズ 3 =] フィルター [合計] マップ qsort
        [6 7 8 8 9 9 10 10 11 12]
```

このセクションの残りの部分では、1 つのシーケンスをパラメータとして受け取り、そのシーケンスのすべての順列 のリストを返す小さなプログラムを構築します 。
最初の草案は次のとおりです。


  
```
1 S にメンバーが 0 つまたは 1 つしかない場合
2 の場合、順列は 1 つだけなので、その単位リストを取得します。

3 他の場合は S の最初と残りを取得します。

                    再帰して残りの順列を構築する
4 すべての順列のすべての位置に最初のものを挿入します
再帰パターンは線形であるため、linrec コンビネータを使用して、この最初の不完全なプログラムに到達できます。

```

  
```
1[小]
2 [ユニットリスト]
3 [アンコン]
4 [ "すべての順列のすべての位置に最初のものを挿入する" ]
5 リンレック
```

Sステップ 3 と 4 の間の匿名再帰により、残りの順列のリストがスタックの一番上に 残ります。

S 次に、これらの結果として生じるすべての置換のすべての位置に、 最初にオリジナルを挿入する必要があります。
これには、各単一の順列を、すべての場所に最初に挿入された元の順列のリストで置き換えることが含まれます。


これは、構築されたプログラムを各順列にmap適用するコンビネータ を必要とします。
元の 1 番目の項目は、現在スタック上の 2 番目の項目です。
構築するプログラムで使用できるようにするために、先頭に ped されます。
必要なプログラムは定数部と変数部から構成されます。
 swap

定数部分をスタックにプッシュする必要があります。
次に、最初のものがcons必要なプログラムに組み込まれます。
次に、 map順列のリストのリストを作成します。
ただし、これは 2 レベルのリストであり、1 レベルである必要があります。
したがって、2 レベルのリストを 1 レベルのリストにフラット化する必要があります。


  
```
4.1 [スワップ
4.2 [「プログラムの定数部分」]
4.3 短所マップ
4.4 「シーケンスのリストの結果のリストを平坦化する」]
```

次に、構築したプログラムの定数部分を記述する必要があります。
map構築されたプログラムは残りのすべての順列に使用され、いずれの場合も、マップされている現在の順列の上に最初に元の順列をプッシュすることから始まります。
次に、これを現在の順列のすべての位置に最初に挿入する必要があります。


これもまた、 による線形再帰を必要としますlinrec。
これを行う 1 つの方法は、この匿名再帰関数にパラメータを 1 つだけ与えることです。
つまり、元の最初の要素を swons初期要素として持つ現在の順列です。
したがって、ここでのタスクは、この初期要素を現在の順列である残りのすべての位置に挿入することです。


  
```
4.2.2.1 現在のシーケンスが小さい場合
4.2.2.2 では、そのユニットリストのみを返します。

4.2.2.3 それ以外の場合は 1. コピーを保持します
                                2. 2番目と
                                3. 2 番目のないシーケンス
                          3 を匿名で再帰します。

4.2.2.4 2番目を挿入するプログラムを構築するmap挿入を行うために
                          使用しますcons1 からのコピーを追加するために

                          使用します。

```

したがって、定数部分 4.2 は次のようになります。

  
```
4.2.1 [ スウォン
4.2.2.1 [小]
4.2.2.2 [ユニットリスト]
4.2.2.3 [dup unswons [uncons] dip swons ]
4.2.2.4 [ スワップ [スウォン] の短所 マップの短所 ]
4.2.2.5 リンレック]
```

他に記述する必要があるのは、平坦化に関する部分だけです。
これはもう簡単なはずです。
リストが小さい場合は、そのユニット リストを取得し、それ以外の場合は最初のリストを取得し、残りを匿名で残りを再帰し、保存された最初のリストを結果に連結します。


必要なプログラムは次のとおりです。



  
```
4.4 [ null ] [ ] [ uncons ] [ concat ] linrec
```

プログラム全体は次のようになります。


  
```
1[小]
2 [ユニットリスト]
3 [アンコン]
4.1 [スワップ
4.2.1 [ スウォン
4.2.2.1 [小]
4.2.2.2 [ユニットリスト]
4.2.2.3 [dup unswons [uncons] dip swons ]
4.2.2.4 [ スワップ [スウォン] の短所 マップの短所 ]
4.2.2.5 リンレック]
4.3 短所マップ
4.4 [null] [] [uncons] [concat] linrec ]
5 リンレック。

```

本質的に同一のプログラムが、Joy ライブラリに という名前で存在します permlist。
insertlist2 つの補助プログラムを使用しており、 flatten他の場所でも役立つため、ここで示したプログラムよりもかなり短くなります。
linrec上記のプログラムは、コンビネータを 3 回、map コンビネータを 2 回使用し、どちらの場合もパラメータとして 構築されたプログラムを使用する、自明ではないプログラムの例です 。


もちろん、そのようなプログラムはLisp、Scheme、ML、 Haskellなどのラムダ計算言語で書くことができますが、付随する名前付き仮パラメータを伴う多くの再帰的定義が必要になります。


## その他
現在の実装には他にも多くの機能があり、それらについてはより専門的なドキュメントで説明するのが最適です。
利用可能な内容の概要については、オンライン ヘルプコマンドの出力を参照してください 。
これにより、すべてのライブラリがロードされたときに、プリミティブと定義された関数の名前のリストのみが得られます。
現在のプリミティブの実際の説明については、オンライン マニュアルコマンドの出力を参照してください 。
定義された関数の定義については、メイン ページのセクション 3 にあるさまざまなライブラリを参照してください。

